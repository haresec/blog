{"posts":[{"title":"Javase-数组","content":"数组 数组是一个最简单的数据结构 数组概述 数组时相同类型数据的有序集合 数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成 其中每一个数据称做一个数组元素，每个数组元素可以通过一个下标来访问他们 数组声明创建 首先必须先声明数组变量，才能在程序中使用数组。 dataType[] arrayRefVar; //首选方法 dataType arrayRefVar[]; //效果相同，但不是首选方法 Java语言使用new操作符创建数组，语法如下： dataType[] arrayRefVar = new dataType[arraySize]; public static void main(String[] args) { // 声明数组 int[] nums; //定义，Java中建议在类型后面添加中括号代表数组 int nums2[]; //c、c++类型定义数组的方式 //创建数组 nums = new int[10]; //可以存放10个int类型的元素 nums[0] = 1; nums[1] = 2; nums[2] = 3; nums[3] = 4; nums[4] = 5; nums[5] = 6; nums[6] = 7; nums[7] = 8; nums[8] = 9; nums[9] = 10; int sum = 0; for (int i =0; i &lt; nums.length; i++){ sum += nums[i]; } System.out.println(&quot;总和为：&quot; + sum); } 静态初始化 int[] a = {1, 2, 3}; Man[] mans = {new Man(1,1), new Man(2,2)}; 动态初始化 int[] a = new int[2]; a[0]=1; a[1]=2; 数组默认初始化 数组是引用类型，他的元素相当于累的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化 public static void main(String[] args) { //静态初始化：创建+赋值 int[] a = {1, 2, 3, 4, 5}; //一旦定义不可改变 System.out.println(a[0]); //动态初始化:声明数组时并未直接进行赋值 int[] b = new int[10]; b[0] = 10; System.out.println(b[0]); System.out.println(b[1]); //默认初始化：数组是一个引用类型，数组一经声明都会有默认初始值，一旦被实例化分配内存空间后都会隐式赋值 } 数组的四个基本特点 数组一旦被创建它的大小就是不可以改变的 数组中的元素必须是相同类型，不能出现其他类型 数组中的元素可以是任何数据类型，包括八大基本类型和引用类型（比如类的实例化对象） 数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组对象存在于堆中 数组边界 数组的下标为[0, length-1]，如果越界会报 ArrayIndexOutOfBoundsException 数组下标异常 数组小结 数组是相同数据类型（数据类型可以为任何类型）的有序集合 数组也是对象。数组元素相当于对象的成员变量 数组一旦被创建，其长度是确定的。 数组使用 for-each循环遍历数组 //JDK1.5 没有下标 数组中的每一个元素 : 数组 //直接遍历数组 for (int array : arrays) { System.out.println(array); } 数组作为参数&amp;&amp;返回值 public static void main(String[] args) { int[] arrays = {1, 2, 3, 4, 5}; int[] result = reverseArray(arrays); printArray(result); } //反转数组: 数组作为返回值 public static int[] reverseArray(int[] array){ int[] result = new int[array.length]; //反转操作 for (int i = 0, j=result.length - 1; i &lt; array.length; i++,j--) { result[j] = array[i]; } return result; } //打印数组元素：数组作为传递给方法 public static void printArray(int[] array){ for (int i = 0; i &lt; array.length; i++) { System.out.print(array[i] + &quot; &quot;); } } 多维数组 多为数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，该二维数组中的每个元素都是一个一维数组。 二维数组 2行5列的数组 int a[][] = new int[2][5]; Arrays类 操作数组的类 Arrays.toString() public static void main(String[] args) { int[] a = {1, 2, 3, 4, 5, 6, 47, 365, 456746, 234, 234234, 785}; System.out.println(a); //打印值为数组对象的hashcode System.out.println(Arrays.toString(a)); //打印正常数组 printArray(a); System.out.println(&quot;===================数组排序===================&quot;); Arrays.sort(a); //对数组进行升序排序 System.out.println(Arrays.toString(a)); } //打印数组 public static void printArray(int[] a){ System.out.print(&quot;[&quot;); for (int i = 0; i &lt; a.length; i++) { if (i == a.length - 1){ System.out.print(a[i]); }else { System.out.print(a[i] + &quot;, &quot;); } } System.out.println(&quot;]&quot;); } 稀疏数组 压缩数组便于保存 package com.Zh1z3ven.array; public class ArrayDemo08 { public static void main(String[] args) { int[][] array1 = new int[11][11]; array1[1][2] = 1; array1[2][3] = 2; System.out.println(&quot;输出原始数组&quot;); for (int[] ints : array1) { for (int anInt : ints) { System.out.print(anInt + &quot;\\t&quot;); } System.out.println(); } //转为细数数组 //获取有效值的个数 int sum = 0; for (int i = 0; i &lt; 11; i++) { for (int j = 0; j &lt; 11; j++) { if (array1[i][j]!=0){ sum++; } } } System.out.println(&quot;有效值的个数：&quot; + sum); //创建一个稀疏数组 int[][] array2 = new int[sum+1][3]; array2[0][0] = 11; array2[0][1] = 11; array2[0][2] = sum; //遍历二维数组，将非零的值存放在稀疏数组中 int count = 0; for (int i = 0; i &lt; array1.length; i++) { for (int j = 0; j &lt; array1[i].length; j++) { if (array1[i][j] != 0){ count++; array2[count][0] = i; //行 array2[count][1] = j; //列 array2[count][2] = array1[i][j]; } } } System.out.println(&quot;稀疏数组&quot;); for (int i = 0; i &lt; array2.length; i++) { System.out.println(array2[i][0] + &quot;\\t&quot; +array2[i][1] + &quot;\\t&quot; +array2[i][2] + &quot;\\t&quot;); } //读取稀疏数组 int[][] array3 = new int[array2[0][0]][array2[0][1]]; for (int i = 1; i &lt; array2.length; i++) { array3[array2[i][0]][array2[i][1]] = array2[i][2]; } //打印 System.out.println(&quot;还原稀疏数组&quot;); for (int[] ints : array3) { for (int anInt : ints) { System.out.print(anInt + &quot;\\t&quot;); } System.out.println(); } } } ","link":"https://haresec.github.io/blog/post/javase-shu-zu/"},{"title":"Javase-方法","content":"何谓方法 system.out.println,那么它是什么呢？ 调用系统类里面标准输出对象out中的方法叫做println方法 Java方法是语句的集合，它们在一起执行一个功能。 方法是解决一类问题的步骤有序组合 方法包含与类或对象中 方法在程序中被创建，在其他地方被引用 设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法得的原子性，也就是一个方法只完成一个功能，这样利于我们后期的扩展。 回顾方法命名规则：首字母小写驼峰命名 方法的定义及调用 方法定义格式： 修饰符 返回值类型 方法名（参数类型 参数名）{ 代码 return 返回值; } 返回值类型：void类型为无类型，所以如果定义返回值类型为void，reurn不需要填写 方法名：为我们定义的方法起名，满足标识符的规范，用来调用方法。 参数列表： 可填写传入参数 参数前面必须携带参数变量类型。 return：方法结束。返回值类型是void，如果在返回值定义其他类型，return返回的结果也必须是返回值类型所填写的类型 public static void main(String[] args) { show(); } public static void show(){ System.out.println(&quot;方法&quot;); } 定义完方法后，方法是会默认加载的，我们还需要在main方法里面去调用该方法。 定义方法注意事项# 方法必须定义在一类中方法外 方法不能定义在另一个方法的里面 return 0; 可以终止方法 方法重载 重载就是在一个类中，有相同的函数名称，但形参不同的函数。 方法的重载规则： 方法名称必须相同。 参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）。 方法返回类型可以相同也可以不相同。 仅仅返回类型不同不足以称为方法的重载。 实现理论： 方法名称相同时，编译器会根据调用方法的参数个数、参数类型等驱逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。 命令行传参 有时候你希望运行一个程序时候在传递给它消息。这要靠命令行传参数给main()函数实现 public class CommandLine{ public static void main(String[] args){ for(int i=0;i&lt;args.length;i++){ System.out.println(&quot;args[&quot;+i+&quot;]:&quot; + args[i]) } } } 可变参数 不定项参数 在方法声明中，在指定参数类型后加一个省略号(...)。 一个方法中旨在指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。 package com.study.method; public class Demo04 { public static void main(String[] args) { Demo04 demo04 = new Demo04(); demo04.test(1,2,3,4,5); } public void test(int...i){ System.out.println(i[0]); System.out.println(i[1]); System.out.println(i[2]); System.out.println(i[3]); System.out.println(i[4]); } } 递归 递归结构包括两部分： 递归头：什么时候不调用自身方法。如果没有头，将陷入死循环。 递归体：什么时候需要调用自身方法。 package com.study.method; public class Demo06 { public static void main(String[] args) { System.out.println(f(5)); } public static int f(int n){ if (n == 1){ return 1; }else { return n*f(n-1); } } } ","link":"https://haresec.github.io/blog/post/javase-fang-fa/"},{"title":"Javase-流程控制","content":"流程控制语句 一个程序里面必不可少的就是流程控制，流程控制无非就是判断和循环。首先先来看看判断语句。 if判断 语法： if (关系表达式){ 语句体; }else{ 语句体; } 执行流程 首先会判断该表达式结果为true还是flase，如果是true就执行语句体，如果是false则执行else里面的内容。 public static void main(String[] args) { int a = 1; if (a==1){ System.out.println(&quot;a:&quot;+a); }else{ System.out.println(&quot;a!=1&quot;); } } switch——选择语句 switch 语句格式： switch(表达式) { case 常量值1: 语句体1; break; case 常量值2: 语句体2; break; ... default: 语句体n+1; break; } 执行流程： 首先计算出表达式的值，然后和case依次比较，如果有对应的值，则执行相应的语句，执行完成时遇到break结束。最后如果所有的case值都不匹配就会执行default里面的语句。 public static void main(String[] args) { int weekday = 6; switch(weekday) { case 1: System.out.println(&quot;星期一&quot;); break; case 2: System.out.println(&quot;星期二&quot;); break; case 3: System.out.println(&quot;星期三&quot;); break; case 4: System.out.println(&quot;星期四&quot;); break; case 5: System.out.println(&quot;星期五&quot;); break; case 6: System.out.println(&quot;星期六&quot;); break; case 7: System.out.println(&quot;星期日&quot;); break; default: System.out.println(&quot;你输入的数字有误&quot;); break; } } 循环语句-for 循环语句可以满足在循环条件的情况下，反复执行一段代码。当在达成某个条件的时候必须把循环条件改为flase，让他结束循环，否则就会出现死循环，一直执行下去。 for循环语句格式： for(初始化表达式;布尔表达式;步进表达式){ 循环体； } 执行流程： 首先初始化一个变量，定义一个表达式和步进表达式，然后循环体执行，如果不满足则继续循环，直到满足布尔表达式的条件则退出循环。 public static void main(String[] args) { for (int i = 0; i &lt; 20; i++) { System.out.println(&quot;Hello World&quot;); } } 这里打印了20次，也就是说这循环了20次，循环条件为i小于20，每次执行i就会加1，加到20次就满足了布尔表达式的条件，退出循环。 在这里步进表达式必须要写，否则会陷入死循环。 循环语句2——while while循环语句格式： 初始化表达式 while(布尔表达式){ 循环体 步进表达式 } public static void main(String[] args) { //while循环实现打印10次HelloWorld //定义初始化变量 int i = 1; //循环条件&lt;=10 while(i&lt;=10){ System.out.println(&quot;HelloWorld&quot;); //步进 i++; } } 循环语句3 do-while do-while和while很类似，可以说基本用法都是一样的，但唯一不同的是while如果表达式满足的话就直接不会执行了，而do-while是先执行一遍里面的循环体再判断表达式满不满足条件。 do...while格式： 初始化表达式 do{ 循环体 步进表达式 }while(布尔表达式); public static void main(String[] args) { int x=1; do { System.out.println(&quot;HelloWorld&quot;); x++; }while(x&lt;=10); } do...while循环的特点：无条件执行一次循环体，即使我们将循环条件直接写成false，也依然会循环一次。 这里再来说说for循环和while的区别。 控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继 续使用，如果想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消 失，能够提高内存的使用效率。 在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。 跳出循环语句 break 使用场景： 终结循环或者是选择结构switch continue 使用场景：结束本次循环，继续下一次的循环 ","link":"https://haresec.github.io/blog/post/javase-liu-cheng-kong-zhi/"},{"title":"Javase-Scanner使用","content":"scanner对象 Java.util.Scanner是Java5新特征，我们可以通过Scanner类来获取用户的输入。 基本语法： Scanner scanner = new Scanner(System.in); 通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用hasNext()与hasNextLine()判断是否还有输入的数据。 next(): 1、一定要读取到有效字符后才可以结束输入 2、对输入有效字符之前遇到的空白，next()方法会自动将其去掉 3、只有输入有效字符才将其后面输入的空白作为分隔符或者结束符 4、next()不能得到带有空格的字符串。 nextLine()： 1、以Enter为结束符，也就是说nextLine()方法返回的是输入回车之前的所有字符 2、可以获得空白。 package com.study.scanner; import java.util.Scanner; public class Demo01 { public static void main(String[] args) { //创建一个扫描器对象，用于接收键盘数据 Scanner scanner = new Scanner(System.in); System.out.println(&quot;使用next方式接收：&quot;); //判断用户有没有输入字符串 if(scanner.hasNext()){ //使用next方式接收 String str = scanner.next(); System.out.println(&quot;输入的内容：&quot;+str); } //凡是属于IO流的类如果不关闭会一直占用资源，要养成好习惯用完就关掉 scanner.close(); } } 接收打印 package com.study.scanner; import java.util.Scanner; public class Demo02 { public static void main(String[] args) { //从键盘接收数据 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入数据：&quot;); String str = scanner.nextLine(); System.out.println(&quot;输出内容为：&quot;+str); scanner.close(); } } Scanner进阶使用 package com.study.scanner; import java.util.Scanner; public class Demo04 { public static void main(String[] args) { //我们可以输入多个数字，并求其总和平均数，每输入一个数字用回车确认，通过输入非数字来结束输入并输出执行结果： Scanner scanner = new Scanner(System.in); //和 double sum = 0; //计算输入了多少个数字 int m = 0; System.out.println(&quot;请输入数据：&quot;); //通过循环判断是否还有输入，并在里面对每一个进行求和统计 while(scanner.hasNextDouble()){ double x = scanner.nextDouble(); m = m + 1; sum = sum + x; } System.out.println(m + &quot;个数的和为&quot; + sum); System.out.println(m + &quot;个数平均值是&quot; + (sum/m)); scanner.close(); } } ","link":"https://haresec.github.io/blog/post/scanner-shi-yong/"},{"title":"JavaSE-基础语法","content":"注释 单行注释： //注释 多行注释： /注释/ 文档注释： /** 文档注释 */ 标识符与关键字 下图为Java中所有的关键字 所有标字识符必须以大小写母或$或_开头，首字母之后可以用数字 不能使用关键字做变量名或方法名 标识符大小写敏感 数据类型 Java是一种强类型语言：要求变量使用要严格符合规定，所有变量必须先定以后才能使用。 Java数据类型分为2大类 基本类型（primitive type）： 1、整数类型： byte占1个字节 ​ short占2个字节 ​ int 占4个字节 （默认） ​ long占8个字节 2、浮点类型：float占4个字节 ​ double占2个字节（默认） 3、字符类型：char占2个字节 4、boolean类型：占1位，true和false 引用类型（reference type） 1、类 class 2、接口 interface 3、数组 array public class Demo01 { public static void main(String[] args) { //八大基本数据类型 定义的变量不赋值则无法使用 byte num1 =10; short num2 = 20; int num3 = 30; long num4 = 40L; //长整型需要在value后面加L // 浮点数 float double float num5 = 10.1F; //float 类型需要在value后加F double num6 = 3.1415926; //字符类型 char name1 = 'A'; //字符串String不是数据类型也不是关键词而是类，必须用&quot;包裹 String name2 = &quot;Hellow World!&quot;; boolean flag = true; System.out.println(num1); System.out.println(num2); System.out.println(num3); System.out.println(num4); System.out.println(num5); System.out.println(num6); System.out.println(name1); System.out.println(name2); System.out.println(flag); } } 类型转换 Java是抢类型语言，在进行运算时，不同类型的数据需要先转换为同一类型在进行运算。 容量从低到高优先级排序，因为浮点型优先级比整型高，所以float虽然容量小于long，但依然优先级高于long。 从 高 --&gt; 低 需要强制类型转换 从 低 --&gt; 高 自动类型转换 强制类型转换： 类型 变量名 = (目标类型名) 需要强制转换的变量名 public class Demo05 { public static void main(String[] args) { // 高 --&gt; 低 ：强制类型转换 int i = 128; byte b = (byte)i; //这里输出结果不为128，因为byte最大值为127，此处内存溢出了，类型转换时需注意相应类型的最大容量，避免内存溢出。 System.out.println(i); System.out.println(b); } //输出结果： 128 -128 自动类型转换： public class Demo05 { public static void main(String[] args) { // 低 --&gt; 高 ：自动类型转换 int j = 128; double c = j; System.out.println(j); System.out.println(c); } //输出结果： 128 128.0 Ps: 不能对布尔值进行类型转换 不能把对象类型转换为不相干的类型 高容量 --&gt; 低容量 强制类型转换 转换时可能存在内存溢出或精度问题 public class Demo03 { public static void main(String[] args) { char c1 = 'a'; char c2 = '中'; System.out.println(c1); System.out.println((int)c1); //强制类型转换 System.out.println(c2); System.out.println((int)c2); } 可以看到进行强制类型转换后输出的为字符对应的ascii值 a 97 中 20013 变量 Java是强类型语言，每个变量都必须声明其类型 变量是Java最基本的存储单元，其要素包含变量名、数据类型、作用域 ps： 每个变量都有类型，类型可以是基本类型（整型、浮点型、字符型、布尔型）也可以是引用类型（类、接口、数组） 变量名必须是合法标识符，也就是必须以大小写字母或$或_开头 声明变量语句注意要以 分号 结束 type varName = [=value] [{,varName[=value]}]; 数据类型 变量名 = 值; //可以使用逗号分隔来同时声明多个变量 变量的作用域 类变量 实例变量 局部变量 public class Demo06 { //类变量，声明格式类似于实例变量，不过需要加static, 随类的出现和消失而出现和消失。 static double salary = 2500; //实例变量，在类的里面方法的外面，从属于对象；如不自行初始化，Java会将其值初始化为这个类型的默认值。 0，0.0, 布尔：false, 其余数据类型：null String name; int age; //main方法 public static void main(String[] args) { //局部变量，在此方法里面，使用时必须声明和初始化值，不可在其他方法调用。 int i = 10; System.out.println(i); //变量类型（Demo06） 变量名（demo06） = 值（new Demo06()） Demo06 demo06 = new Demo06(); System.out.println(demo06.age); System.out.println(demo06.name); System.out.println(salary); } //其他方法 public void add(){ } 常量 常量初始化后，常量值不可改变，可理解为特殊的变量 常量名一般使用大写字符 final 常量名 = 常量值;final i = 10; public class Demo07 { //修饰符（static、final等）无先后顺序 static final int I = 10; public static void main(String[] args) { System.out.println(I); }} 变量命名规范 修饰符# static 将方法变为类的方法，被修饰的方法可以在类里直接引用而不需要先创建对象。 public 公有的，如果想让子类也可以使用此属性或方法，需要用public修饰 protected 受保护的，同包不同级，不可以跨包使用 default 默认为default private 私有的，私有的属性和方法是可以被继承的，但是仅限被类访问，子类一般无法直接调用及访问。一般属性也是私有的 final 通过final修饰得类没有子类 运算符# % 模 取余运算instanceof==实例注意a++与++a的区别，a++先赋值再+1，++a先+1再赋值 package operator; public class Demo2 {public static void main(String[] args) { long a = 123123123123123123L; int b = 123; short c = 10; byte d = 8; // 返回结果为操作数中最高位 System.out.println(a+b+c+d); System.out.println(b+c+d); System.out.println(c+d); } }12312312312312326414118 当操作数中有long，则返回值类型为long；操作数中无long时，返回结果为操作数中最高位 自增自减运算符、Math类# Java.lang下的包不需要导入 package operator; public class Demo3 { public static void main(String[] args) { int a = 3; //先赋值再+1 int b = a++; //先+1再赋值 int c = ++a; System.out.println(a); System.out.println(b); System.out.println(c); //java.lang下的包不需要导入； double pow = new Math.pow(2,3); System.out.println(pow); }} 逻辑运算符 package operator; public class Demo03 { public static void main(String[] args) { //与（and） 或(or) 非（取反） boolean a = true; boolean b = false; System.out.println(&quot;a &amp;&amp; b:&quot;+(a &amp;&amp; b)); System.out.println(&quot;a | b:&quot;+(a || b)); System.out.println(&quot;!(a &amp;&amp; b:)&quot;+(!(a &amp;&amp; b))); //短路运算 int c = 5; boolean d = (c&lt;4)&amp;&amp;(c++&lt;4); System.out.println(d); System.out.println(c); } } 位运算符 package operator; public class Demo04 { public static void main(String[] args) { /* A = 0011 1100 b = 0000 1101 A&amp;B = 0000 1100 &quot;&amp;&quot;如果相对应位都是1，则结果为1，否则为0 A|B = 0011 1101 &quot;|&quot;如果对应位都是0，则结果为0，否则为1 A^B = 0011 0001 “^”如果相同为0，否则为1 ~B = 1111 0010 取反 2*8 = 16 &lt;&lt; *2 &gt;&gt; *2 0000 0000 0 0000 0001 1 0000 0010 2 0000 0011 3 0000 0100 4 0000 1000 8 0001 0000 16 */ System.out.println(2&lt;&lt;3); } } Java包机制# 包可以理解为一个文件夹 为了更好的组织类，Java提供了包机制，用于区别类名的命名空间。 语法： package pkg1[.pkg2[.pkg3...]]; 一般利用公司域名倒置作为包名 例如：com.baidu.www 为了能够使用某一个包的成员，我们需要在Java程序中明确导入该包。 import package1[.package2...].(classname|*); import语句必须在package语句下面，不然会报错 IDEA默认开启了Compact Middle Packages,需要取消勾选才可一次性生成多级package ","link":"https://haresec.github.io/blog/post/javase/"}]}